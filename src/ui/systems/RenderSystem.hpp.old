/**
 * ************************************************************************
 *
 * @file RenderSystem.h
 * @author AnakinLiu (azrael2759@qq.com)
 * @date 2026-01-13
 * @version 0.1
 * @brief SDL GPU 渲染系统

  - 负责使用 SDL3 GPU 模块进行 UI 渲染
  - 响应 UI 渲染事件，执行实际渲染操作

  加载assets/sharder/spir-v文件

  支持的图形后端列表

    - Vulkan 默认
    - DX12

    使用 stb_truetype 渲染字体到GPU纹理上
    默认字体用 assets/fonts/NotoSansSC-VariableFont_wght.ttf
    静态资源都用cmrc打包
    驱动和窗口是1对多关系
    所有窗口共用同一个GPU设备
    窗口数量可能变化
 *
 * ************************************************************************
 * @copyright Copyright (c) 2026 AnakinLiu
 * For study and research only, no reprinting.
 * ************************************************************************
 */

#pragma once
#include <cstddef>
#include <cstdint>
#include <cmath>
#include <memory>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <cstdlib>
#include <optional>
#include <stack>
#include <SDL3/SDL.h>
#include <SDL3/SDL_gpu.h>
#include <SDL3/SDL_video.h>
#include <entt/entt.hpp>
#include <Eigen/Dense>
#include <cmrc/cmrc.hpp>
#include <entt/entt.hpp>
#include "../singleton/Logger.hpp"
#include "../singleton/Registry.hpp"
#include "../singleton/Dispatcher.hpp"

#include "../common/Components.hpp"
#include "../common/Tags.hpp"
#include "../common/Events.hpp"
#include "../interface/Isystem.hpp"
#include "../api/Utils.hpp"
#include "../api/Layout.hpp"
#include "../common/RenderTypes.hpp"
#include "../managers/FontManager.hpp"
#include "../managers/DeviceManager.hpp"
#include "../managers/PipelineCache.hpp"
#include "../managers/TextTextureCache.hpp"
#include "../managers/BatchManager.hpp"
#include "../managers/CommandBuffer.hpp"
#include "../core/IRenderer.hpp"
#include "../core/RenderContext.hpp"

CMRC_DECLARE(ui_fonts); // NOLINT

namespace ui::systems
{
/**
 * @brief SDL GPU 渲染系统
 *
 * 使用 SDL3 GPU API 实现高性能 UI 渲染，替代 ImGui DrawList
 */
class RenderSystem final : public interface::EnableRegister<RenderSystem>
{
public:
    RenderSystem()
        : m_deviceManager(std::make_unique<managers::DeviceManager>()),
          m_fontManager(std::make_unique<managers::FontManager>()), m_pipelineCache(nullptr),
          m_textTextureCache(nullptr), m_batchManager(std::make_unique<managers::BatchManager>()),
          m_commandBuffer(nullptr)
    {
        Logger::info("[RenderSystem] 构造完成，等待初始化...");
        m_stats.frameCount = 0;
        m_stats.batchCount = 0;
        m_stats.vertexCount = 0;
    };
    RenderSystem(const RenderSystem&) = delete;
    RenderSystem& operator=(const RenderSystem&) = delete;
    RenderSystem(RenderSystem&&) noexcept = default;
    RenderSystem& operator=(RenderSystem&&) noexcept = default;
    ~RenderSystem() { cleanup(); }

    // Debug 统计信息
    struct RenderStats
    {
        uint64_t frameCount = 0;
        uint32_t batchCount = 0;
        uint32_t vertexCount = 0;
        uint32_t textureCount = 0;
        float lastFrameTime = 0.0f;
    };

    const RenderStats& getStats() const { return m_stats; }

    /**
     * @brief 注册事件处理器
     */
    void registerHandlersImpl()
    {
        Dispatcher::Sink<events::WindowGraphicsContextSetEvent>().connect<&RenderSystem::onWindowsGraphicsContextSet>(
            *this);
        Dispatcher::Sink<events::WindowGraphicsContextUnsetEvent>()
            .connect<&RenderSystem::onWindowsGraphicsContextUnset>(*this);
        Dispatcher::Sink<events::UpdateRendering>().connect<&RenderSystem::update>(*this);
    }

    /**
     * @brief 注销事件处理器
     */
    void unregisterHandlersImpl()
    {
        Dispatcher::Sink<events::WindowGraphicsContextSetEvent>()
            .disconnect<&RenderSystem::onWindowsGraphicsContextSet>(*this);
        Dispatcher::Sink<events::WindowGraphicsContextUnsetEvent>()
            .disconnect<&RenderSystem::onWindowsGraphicsContextUnset>(*this);
        Dispatcher::Sink<events::UpdateRendering>().disconnect<&RenderSystem::update>(*this);
    }

private:
    /**
     * @brief 处理图形上下文设置事件
     */
    void onWindowsGraphicsContextSet(const events::WindowGraphicsContextSetEvent& event)
    {
        ensureInitialized();
        uint32_t windowID = Registry::Get<components::Window>(event.entity).windowID;
        SDL_Window* sdlWindow = SDL_GetWindowFromID(windowID);
        if (sdlWindow == nullptr)
        {
            Logger::warn("[RenderSystem] 无法获取 SDL_Window (ID: {})", windowID);
            return;
        }
        // 声明窗口给 GPU 设备
        if (!m_deviceManager->claimWindow(sdlWindow))
        {
            Logger::error("[RenderSystem] 无法声明窗口 (ID: {})", windowID);
            return;
        }
        // 为窗口创建渲染管线
        m_pipelineCache->createPipeline(sdlWindow);

        Logger::info("[RenderSystem] 窗口图形上下文设置完成 (Entity: {})", static_cast<uint32_t>(event.entity));
    }

    void onWindowsGraphicsContextUnset(const events::WindowGraphicsContextUnsetEvent& event)
    {
        // 尝试获取窗口组件以查找 SDL_Window
        if (auto* windowComp = Registry::TryGet<components::Window>(event.entity))
        {
            SDL_Window* sdlWindow = SDL_GetWindowFromID(windowComp->windowID);
            if (sdlWindow != nullptr)
            {
                m_deviceManager->unclaimWindow(sdlWindow);
                Logger::info("已从 GPU 设备释放窗口 (ID: {})", windowComp->windowID);
            }
        }
    }

    /**
     * @brief 清理资源
     */
    void cleanup()
    {
        SDL_GPUDevice* device = m_deviceManager->getDevice();
        if (device == nullptr) return;

        // 等待 GPU 空闲
        SDL_WaitForGPUIdle(device);

        m_textTextureCache->clear();

        // 清理白色纹理
        if (m_whiteTexture != nullptr)
        {
            SDL_ReleaseGPUTexture(device, m_whiteTexture);
            m_whiteTexture = nullptr;
        }

        // 清理 GPU 资源
        if (m_vertexBuffer != nullptr)
        {
            SDL_ReleaseGPUBuffer(device, m_vertexBuffer);
            m_vertexBuffer = nullptr;
        }

        if (m_indexBuffer != nullptr)
        {
            SDL_ReleaseGPUBuffer(device, m_indexBuffer);
            m_indexBuffer = nullptr;
        }

        // Managers manage their own resources
        m_batches.clear();
        m_claimedWindows.clear(); // Wait, m_claimedWindows is gone from Members, DeviceManager handles it.

        m_pipelineCache.reset();
        m_textTextureCache.reset();
        m_fontManager.reset();
        m_deviceManager->cleanup();
    }

    /**
     * @brief 创建默认白色纹理（用于纯色渲染）
     */
    void createWhiteTexture()
    {
        SDL_GPUDevice* device = m_deviceManager->getDevice();
        if (device == nullptr) return;

        SDL_GPUTextureCreateInfo texInfo = {};
        texInfo.type = SDL_GPU_TEXTURETYPE_2D;
        texInfo.format = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM;
        texInfo.width = 1;
        texInfo.height = 1;
        texInfo.layer_count_or_depth = 1;
        texInfo.num_levels = 1;
        texInfo.usage = SDL_GPU_TEXTUREUSAGE_SAMPLER;

        m_whiteTexture = SDL_CreateGPUTexture(device, &texInfo);
        if (m_whiteTexture == nullptr) return;

        // 上传 1x1 白色像素
        uint32_t whitePixel = 0xFFFFFFFF;
        SDL_GPUTransferBufferCreateInfo transferInfo = {};
        transferInfo.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
        transferInfo.size = sizeof(whitePixel);

        SDL_GPUTransferBuffer* transfer = SDL_CreateGPUTransferBuffer(device, &transferInfo);

        void* data = SDL_MapGPUTransferBuffer(device, transfer, false);
        SDL_memcpy(data, &whitePixel, sizeof(whitePixel));
        SDL_UnmapGPUTransferBuffer(device, transfer);

        SDL_GPUCommandBuffer* cmd = SDL_AcquireGPUCommandBuffer(device);
        SDL_GPUCopyPass* copyPass = SDL_BeginGPUCopyPass(cmd);

        SDL_GPUTextureTransferInfo srcInfo = {};
        srcInfo.transfer_buffer = transfer;
        srcInfo.pixels_per_row = 1;
        srcInfo.rows_per_layer = 1;

        SDL_GPUTextureRegion dstRegion = {};
        dstRegion.texture = m_whiteTexture;
        dstRegion.w = 1;
        dstRegion.h = 1;
        dstRegion.d = 1;

        SDL_UploadToGPUTexture(copyPass, &srcInfo, &dstRegion, false);
        SDL_EndGPUCopyPass(copyPass);
        SDL_SubmitGPUCommandBuffer(cmd);
        SDL_ReleaseGPUTransferBuffer(device, transfer);
    }

    /**
     * @brief 主渲染更新函数
     */
    void update() noexcept
    {
        static bool firstUpdate = true;
        auto windowView = Registry::View<components::Window, components::RenderDirtyTag>();
        // 检查是否有窗口
        if (windowView.begin() == windowView.end())
        {
            return;
        }
        if (firstUpdate)
        {
            Logger::info("[RenderSystem] update first call");
            firstUpdate = false;
        }

        ensureInitialized();
        SDL_GPUDevice* device = m_deviceManager->getDevice();
        if (device == nullptr)
        {
            Logger::warnOnce("GPU device not ready");
            return;
        }

        if (m_pipelineCache == nullptr || m_pipelineCache->getPipeline() == nullptr)
        {
            Logger::warnOnce("Pipeline not ready");
            return;
        }

        // 延迟创建白色纹理
        if (m_whiteTexture == nullptr)
        {
            createWhiteTexture();
        }

        // Statistics reset
        m_stats.frameCount++;
        m_stats.batchCount = 0;
        m_stats.vertexCount = 0;

        // 遍历每个窗口进行渲染
        for (auto windowEntity : windowView)
        {
            auto& windowComp = windowView.get<components::Window>(windowEntity);
            SDL_Window* sdlWindow = SDL_GetWindowFromID(windowComp.windowID);
            if (sdlWindow == nullptr)
            {
                Logger::warn("窗口实体的 sdlWindow 为空");
                continue;
            }

            // 获取当前窗口大小
            int width = 0;
            int height = 0;
            SDL_GetWindowSizeInPixels(sdlWindow, &width, &height);
            if (width <= 0 || height <= 0) continue;

            m_screenWidth = static_cast<float>(width);
            m_screenHeight = static_cast<float>(height);

            // 清空渲染批次
            m_batchManager->clear();

            // 收集当前窗口及其子元素的渲染数据
            if (Registry::AnyOf<components::VisibleTag>(windowEntity))
            {
                // 创建根上下文
                core::RenderContext rootContext;
                rootContext.screenWidth = m_screenWidth;
                rootContext.screenHeight = m_screenHeight;
                rootContext.deviceManager = m_deviceManager.get();
                rootContext.fontManager = m_fontManager.get();
                rootContext.batchManager = m_batchManager.get();
                rootContext.sdlWindow = sdlWindow;

                // 窗口实体的 Position 是屏幕坐标，而渲染是在窗口坐标系中进行的
                Eigen::Vector2f rootOffset = Eigen::Vector2f(0, 0);
                if (const auto* pos = Registry::TryGet<components::Position>(windowEntity))
                {
                    rootOffset = -pos->value;
                }

                rootContext.position = rootOffset;
                rootContext.alpha = 1.0F;

                collectRenderData(windowEntity, rootContext);
            }

            // 优化批次
            m_batchManager->optimize();

            // 执行 GPU 渲染
            const auto& batches = m_batchManager->getBatches();
            if (!batches.empty())
            {
                m_commandBuffer->execute(sdlWindow, width, height, batches);
                m_stats.batchCount += static_cast<uint32_t>(batches.size());
                m_stats.vertexCount += static_cast<uint32_t>(m_batchManager->getTotalVertexCount());
            }
        }

        // 清除脏标记
        auto dirtyView = Registry::View<components::RenderDirtyTag>();
        for (auto entity : dirtyView)
        {
            Registry::Remove<components::RenderDirtyTag>(entity);
        }
    }

    // 窗口属性同步函数已迁移至 StateSystem

private:
    void ensureInitialized()
    {
        if ((SDL_WasInit(SDL_INIT_VIDEO) & SDL_INIT_VIDEO) == 0)
        {
            return;
        }

        if (!m_deviceManager->initialize())
        {
            Logger::error("Failed to initialize RenderSystem: GPU device initialization failed");
            return;
        }

        if (m_pipelineCache == nullptr)
        {
            m_pipelineCache = std::make_unique<managers::PipelineCache>(*m_deviceManager);
            m_pipelineCache->loadShaders();
        }

        if (!m_fontManager->isLoaded())
        {
            // load default font
            auto filesystem = cmrc::ui_fonts::get_filesystem();
            const char* fontPath = "assets/fonts/NotoSansSC-VariableFont_wght.ttf";
            if (filesystem.exists(fontPath))
            {
                auto fontFile = filesystem.open(fontPath);
                m_fontManager->loadFromMemory(reinterpret_cast<const uint8_t*>(fontFile.begin()),
                                              static_cast<size_t>(fontFile.size()),
                                              24.0F,
                                              2.0F);
            }
        }

        if (m_textTextureCache == nullptr)
        {
            m_textTextureCache = std::make_unique<managers::TextTextureCache>(*m_deviceManager, *m_fontManager);
        }

        if (m_commandBuffer == nullptr)
        {
            m_commandBuffer = std::make_unique<managers::CommandBuffer>(*m_deviceManager, *m_pipelineCache);
        }

        // 初始化渲染器
        if (m_renderers.empty())
        {
            initializeRenderers();
        }
    }

    /**
     * @brief 递归收集渲染数据
     * @param registry  注册表
     * @param entity  当前实体
     * @param parentPos  父实体位置
     * @param parentAlpha  父实体透明度
     * @param sdlWindow  SDL 窗口指针
     */
    void collectRenderData(entt::entity entity,
                           const Eigen::Vector2f& parentPos,
                           float parentAlpha,
                           SDL_Window* sdlWindow = nullptr)
    {
        if (!Registry::AnyOf<components::VisibleTag>(entity)) return;
        if (Registry::AnyOf<components::SpacerTag>(entity)) return;

        const auto& pos = Registry::Get<components::Position>(entity);
        const auto& size = Registry::Get<components::Size>(entity);
        const auto* alphaComp = Registry::TryGet<components::Alpha>(entity);

        float globalAlpha = parentAlpha * (alphaComp ? alphaComp->value : 1.0F);
        Eigen::Vector2f absolutePos = parentPos + pos.value;
        Eigen::Vector2f contentOffset(0.0F, 0.0F);

        // Window/Dialog 目前按普通容器渲染（背景 + 子元素），后续再做特殊处理

        // 处理 ScrollArea
        const auto* scrollArea = Registry::TryGet<components::ScrollArea>(entity);
        bool pushScissor = false;
        if (scrollArea != nullptr)
        {
            SDL_Rect currentScissor;
            currentScissor.x = static_cast<int>(absolutePos.x());
            currentScissor.y = static_cast<int>(absolutePos.y());
            currentScissor.w = static_cast<int>(size.size.x());
            currentScissor.h = static_cast<int>(size.size.y());

            // 保持与父级裁剪区域的交集
            if (!m_scissorStack.empty())
            {
                const SDL_Rect& parentRect = m_scissorStack.back();
                if (!SDL_GetRectIntersection(&currentScissor, &parentRect, &currentScissor))
                {
                    // 不可见时设置为空
                    currentScissor.w = 0;
                    currentScissor.h = 0;
                }
            }

            m_scissorStack.push_back(currentScissor);
            pushScissor = true;
            contentOffset = -scrollArea->scrollOffset;
        }

        // 收集背景渲染数据
        collectBackgroundData(entity, absolutePos, size.size, globalAlpha);

        // 收集特定组件渲染数据
        collectComponentData(entity, absolutePos, size.size, globalAlpha, sdlWindow);

        // 递归处理子元素
        const auto* hierarchy = Registry::TryGet<components::Hierarchy>(entity);
        if (hierarchy && !hierarchy->children.empty())
        {
            for (entt::entity child : hierarchy->children)
            {
                // 子元素位置受滚动偏移影响
                collectRenderData(child, absolutePos + contentOffset, globalAlpha, sdlWindow);
            }
        }

        if (pushScissor)
        {
            // 绘制滚动条 (在裁剪之前)
            drawScrollBars(entity, absolutePos, size.size, *scrollArea, globalAlpha);

            m_scissorStack.pop_back();
        }
    }

    void drawScrollBars(entt::entity entity,
                        const Eigen::Vector2f& pos,
                        const Eigen::Vector2f& size,
                        const components::ScrollArea& scrollArea,
                        float alpha)
    {
        if (scrollArea.showScrollbars == policies::ScrollBarVisibility::AlwaysOff) return;

        // 计算可视区域高度（减去垂直内边距）
        float viewportHeight = size.y();
        if (const auto* padding = Registry::TryGet<components::Padding>(entity))
        {
            viewportHeight = std::max(0.0F, size.y() - padding->values.x() - padding->values.z());
        }

        // 简单绘制一个垂直滚动条
        bool hasVerticalScroll =
            (scrollArea.scroll == policies::Scroll::Vertical || scrollArea.scroll == policies::Scroll::Both);
        if (hasVerticalScroll && scrollArea.contentSize.y() > viewportHeight)
        {
            float trackSize = size.y();
            float visibleRatio = viewportHeight / scrollArea.contentSize.y();
            float thumbSize = std::max(20.0f, trackSize * visibleRatio);
            float maxScroll = std::max(0.0f, scrollArea.contentSize.y() - viewportHeight);
            float scrollRatio =
                maxScroll > 0.0f ? std::clamp(scrollArea.scrollOffset.y() / maxScroll, 0.0f, 1.0f) : 0.0f;
            float thumbPos = (trackSize - thumbSize) * scrollRatio;

            // 确保滑块位置不超出轨道
            thumbPos = std::clamp(thumbPos, 0.0f, trackSize - thumbSize);

            // 绘制滑块
            float barWidth = 10.0f;
            Eigen::Vector2f barPos(pos.x() + size.x() - barWidth - 2.0f, pos.y() + thumbPos);
            Eigen::Vector2f barSize(barWidth, thumbSize);

            addRectFilledWithRounding(barPos, barSize, {0.6f, 0.6f, 0.6f, 0.8f}, {5.0f, 5.0f, 5.0f, 5.0f}, alpha);
        }
    }

    /** */
    void
        collectBackgroundData(entt::entity entity, const Eigen::Vector2f& pos, const Eigen::Vector2f& size, float alpha)
    {
        // 获取阴影信息
        const auto* shadow = Registry::TryGet<components::Shadow>(entity);
        float shadowSoft = 0.0F;
        float shadowOffsetX = 0.0F;
        float shadowOffsetY = 0.0F;
        if (shadow && shadow->enabled == policies::Feature::Enabled)
        {
            shadowSoft = shadow->softness;
            shadowOffsetX = shadow->offset.x();
            shadowOffsetY = shadow->offset.y();
        }

        const auto* bg = Registry::TryGet<components::Background>(entity);
        if (bg && bg->enabled == policies::Feature::Enabled)
        {
            Eigen::Vector4f color(bg->color.red, bg->color.green, bg->color.blue, bg->color.alpha);
            Eigen::Vector4f radius(
                bg->borderRadius.x(), bg->borderRadius.y(), bg->borderRadius.z(), bg->borderRadius.w());
            addRectFilledWithRounding(pos, size, color, radius, alpha, shadowSoft, shadowOffsetX, shadowOffsetY);
        }

        const auto* border = Registry::TryGet<components::Border>(entity);
        bool focused = Registry::AnyOf<components::FocusedTag>(entity);

        if (focused || (border && border->thickness > 0.0F))
        {
            Eigen::Vector4f color(0.0f, 0.0f, 0.0f, 1.0f);
            Eigen::Vector4f radius(0.0f, 0.0f, 0.0f, 0.0f);
            float thickness = 0.0f;

            if (border)
            {
                color =
                    Eigen::Vector4f(border->color.red, border->color.green, border->color.blue, border->color.alpha);
                radius = Eigen::Vector4f(border->borderRadius.x(),
                                         border->borderRadius.y(),
                                         border->borderRadius.z(),
                                         border->borderRadius.w());
                thickness = border->thickness;
            }

            if (focused)
            {
                color = Eigen::Vector4f(0.2f, 0.6f, 1.0f, 1.0f); // Blue focus ring
                if (thickness < 2.0f) thickness = 2.0f;
            }

            if (thickness > 0.0f)
            {
                // TODO: 边框需要单独的着色器处理，暂时用线段绘制
                addRect(pos, pos + size, color, thickness, alpha);
            }
        }
    }

    /**
     * @brief 收集组件特定渲染数据
     */
    void collectComponentData(entt::entity entity,
                              const Eigen::Vector2f& pos,
                              const Eigen::Vector2f& size,
                              float alpha,
                              SDL_Window* sdlWindow = nullptr)
    {
        // 文本渲染（普通文本、按钮、标签）
        if (Registry::AnyOf<components::TextTag, components::ButtonTag, components::LabelTag>(entity))
        {
            const auto* textComp = Registry::TryGet<components::Text>(entity);
            if (textComp && !textComp->content.empty())
            {
                Eigen::Vector4f color(
                    textComp->color.red, textComp->color.green, textComp->color.blue, textComp->color.alpha);

                policies::TextWrap wrapMode = textComp->wordWrap;
                float wrapWidth = textComp->wrapWidth;

                if (wrapMode == policies::TextWrap::None)
                {
                    // 如果在 ScrollArea 内，默认启用换行
                    float inferredWidth = getAncestorScrollAreaTextWidth(entity);
                    if (inferredWidth > 0.0F)
                    {
                        wrapMode = policies::TextWrap::Word;
                        wrapWidth = inferredWidth;
                    }
                }

                if (wrapMode != policies::TextWrap::None && wrapWidth <= 0.0F)
                {
                    wrapWidth = size.x();
                }

                if (wrapMode != policies::TextWrap::None && wrapWidth > 0.0F)
                {
                    // 根据换行结果动态修正自动高度，避免滚动区内容高度不匹配
                    if (auto* sizeComp = Registry::TryGet<components::Size>(entity))
                    {
                        if (policies::HasFlag(sizeComp->sizePolicy, policies::Size::VAuto))
                        {
                            const float lineHeight = static_cast<float>(m_fontManager->getFontHeight());
                            if (lineHeight > 0.0F)
                            {
                                const auto lines =
                                    wrapTextLines(textComp->content, static_cast<int>(wrapWidth), wrapMode);
                                const float desiredHeight = static_cast<float>(lines.size()) * lineHeight;
                                if (std::abs(sizeComp->size.y() - desiredHeight) > 0.5F)
                                {
                                    sizeComp->size.y() = desiredHeight;
                                    Registry::EmplaceOrReplace<components::LayoutDirtyTag>(entity);
                                }
                            }
                        }
                    }

                    addWrappedText(
                        textComp->content, pos, size, color, textComp->alignment, wrapMode, wrapWidth, alpha);
                }
                else
                {
                    addText(textComp->content, pos, size, color, textComp->alignment, alpha);
                }
            }

            // Icon 渲染逻辑 - 如果控件有 Icon 组件，则渲染图标
            if (const auto* iconComp = Registry::TryGet<components::Icon>(entity))
            {
                if (iconComp->textureId)
                {
                    renderIcon(entity, iconComp, pos, size, alpha);
                }
            }
        }

        // 文本输入框渲染
        if (Registry::AnyOf<components::TextEditTag>(entity))
        {
            const auto* textComp = Registry::TryGet<components::Text>(entity);
            const auto* textEdit = Registry::TryGet<components::TextEdit>(entity);
            if (textComp != nullptr && textEdit != nullptr)
            {
                // 计算文本区域（考虑内边距）
                Eigen::Vector2f textPos = pos;
                Eigen::Vector2f textSize = size;
                if (const auto* padding = Registry::TryGet<components::Padding>(entity))
                {
                    textPos.x() += padding->values.w();
                    textPos.y() += padding->values.x();
                    textSize.x() = std::max(0.0F, textSize.x() - padding->values.y() - padding->values.w());
                    textSize.y() = std::max(0.0F, textSize.y() - padding->values.x() - padding->values.z());
                }

                // 在输入框内部裁剪，避免文本溢出
                bool pushScissor = false;
                SDL_Rect currentScissor;
                currentScissor.x = static_cast<int>(textPos.x());
                currentScissor.y = static_cast<int>(textPos.y());
                currentScissor.w = static_cast<int>(textSize.x());
                currentScissor.h = static_cast<int>(textSize.y());

                if (!m_scissorStack.empty())
                {
                    const SDL_Rect& parentRect = m_scissorStack.back();
                    if (!SDL_GetRectIntersection(&currentScissor, &parentRect, &currentScissor))
                    {
                        currentScissor.w = 0;
                        currentScissor.h = 0;
                    }
                }
                m_scissorStack.push_back(currentScissor);
                pushScissor = true;

                std::string displayText = textEdit->buffer;
                Eigen::Vector4f color(
                    textComp->color.red, textComp->color.green, textComp->color.blue, textComp->color.alpha);

                // 如果没有内容且有 placeholder，显示 placeholder（灰色）
                if (displayText.empty() && !textEdit->placeholder.empty())
                {
                    displayText = textEdit->placeholder;
                    color = Eigen::Vector4f(0.5F, 0.5F, 0.5F, alpha);
                }

                const float lineHeight = static_cast<float>(m_fontManager->getFontHeight());

                const auto modeVal = static_cast<uint8_t>(textEdit->inputMode);
                const auto multiFlag = static_cast<uint8_t>(policies::TextFlag::Multiline);

                if ((modeVal & multiFlag) == 0)
                {
                    // 单行：水平滚动显示尾部
                    float visibleWidth = 0.0F;
                    std::string visibleText =
                        getTailThatFits(displayText, static_cast<int>(textSize.x()), visibleWidth);

                    const policies::Alignment align = policies::Alignment::LEFT | policies::Alignment::VCENTER;
                    if (!visibleText.empty())
                    {
                        addText(visibleText, textPos, textSize, color, align, alpha);
                    }

                    // 绘制光标 (仅当获焦时)
                    if (Registry::AnyOf<components::FocusedTag>(entity))
                    {
                        float cursorX = textPos.x() + visibleWidth;
                        float cursorY = textPos.y() + (textSize.y() - lineHeight) * 0.5F;

                        if ((SDL_GetTicks() / 500) % 2 == 0)
                        {
                            addRectFilledWithRounding(
                                {cursorX, cursorY}, {2.0F, lineHeight}, {1.0F, 1.0F, 1.0F, 1.0F}, {0, 0, 0, 0}, alpha);
                        }

                        if (sdlWindow)
                        {
                            SDL_Rect rect;
                            rect.x = static_cast<int>(cursorX);
                            rect.y = static_cast<int>(cursorY);
                            rect.w = 2;
                            rect.h = static_cast<int>(lineHeight);
                            SDL_SetTextInputArea(sdlWindow, &rect, 0);
                        }
                    }
                }
                else
                {
                    // 多行：自动换行 + 支持滚动
                    policies::TextWrap wrapMode =
                        textComp->wordWrap != policies::TextWrap::None ? textComp->wordWrap : policies::TextWrap::Word;
                    std::vector<std::string> lines =
                        wrapTextLines(displayText, static_cast<int>(textSize.x()), wrapMode);

                    // 计算文本总高度并更新 ScrollArea contentSize
                    float totalTextHeight = lines.size() * lineHeight;
                    if (auto* scrollArea = Registry::TryGet<components::ScrollArea>(entity))
                    {
                        // 视口高度即为当前的 textSize.y() (已去除 Padding)
                        float viewportHeight = textSize.y();

                        if (scrollArea->contentSize.y() != totalTextHeight)
                        {
                            float oldHeight = scrollArea->contentSize.y();
                            float newHeight = totalTextHeight;

                            scrollArea->contentSize.x() = textSize.x();
                            scrollArea->contentSize.y() = totalTextHeight;

                            // 应用锚定策略
                            if (scrollArea->anchor == policies::ScrollAnchor::Bottom)
                            {
                                // 锚定底部：Offset 随高度差增加，保持距离底部不变
                                scrollArea->scrollOffset.y() += (newHeight - oldHeight);
                            }
                            else if (scrollArea->anchor == policies::ScrollAnchor::Smart)
                            {
                                // 智能模式：如果之前在底部，则保持在底部
                                float oldMaxScroll = std::max(0.0F, oldHeight - viewportHeight);
                                // 给予 2.0 像素的容差
                                bool wasAtBottom = (scrollArea->scrollOffset.y() >= oldMaxScroll - 2.0F);

                                if (wasAtBottom)
                                {
                                    float newMaxScroll = std::max(0.0F, newHeight - viewportHeight);
                                    scrollArea->scrollOffset.y() = newMaxScroll;
                                }
                            }
                        }

                        // 始终更新宽度记录
                        scrollArea->contentSize.x() = textSize.x();

                        // 始终执行 Clamping，防止视口变化(Resize)导致的越界
                        // 注意：这里使用当前的 totalTextHeight 和 viewportHeight 进行计算
                        float maxScroll = std::max(0.0F, totalTextHeight - viewportHeight);
                        scrollArea->scrollOffset.y() = std::clamp(scrollArea->scrollOffset.y(), 0.0F, maxScroll);

                        // 使用滚动偏移来确定起始行
                        const int maxVisibleLines = lineHeight > 0.0F ? static_cast<int>(textSize.y() / lineHeight) : 0;
                        const int scrollOffsetLines =
                            lineHeight > 0.0F ? static_cast<int>(scrollArea->scrollOffset.y() / lineHeight) : 0;
                        const size_t startIndex =
                            std::min(static_cast<size_t>(scrollOffsetLines), lines.size() > 0 ? lines.size() - 1 : 0);
                        const size_t endIndex =
                            std::min(startIndex + static_cast<size_t>(maxVisibleLines) + 1, lines.size());

                        float y = textPos.y() - (scrollArea->scrollOffset.y() - scrollOffsetLines * lineHeight);
                        for (size_t i = startIndex; i < endIndex; ++i)
                        {
                            const std::string& line = lines[i];
                            if (!line.empty())
                            {
                                addText(line,
                                        {textPos.x(), y},
                                        {textSize.x(), lineHeight},
                                        color,
                                        policies::Alignment::LEFT,
                                        alpha);
                            }
                            y += lineHeight;
                        }

                        // 绘制光标 (仅当获焦时) - ScrollArea 分支
                        if (Registry::AnyOf<components::FocusedTag>(entity))
                        {
                            float cursorX = textPos.x();
                            float cursorY = textPos.y();

                            if (!lines.empty())
                            {
                                // 光标在最后一行末尾
                                const std::string& lastLine = lines.back();
                                float lastWidth = measureTextWidth(lastLine);

                                // 计算光标在可见区域中的位置
                                const int lastLineIndex = static_cast<int>(lines.size()) - 1;

                                // 如果最后一行在可见区域内
                                if (lastLineIndex >= scrollOffsetLines &&
                                    lastLineIndex < scrollOffsetLines + maxVisibleLines)
                                {
                                    const int visibleLineIndex = lastLineIndex - scrollOffsetLines;
                                    cursorY = textPos.y() + visibleLineIndex * lineHeight -
                                              (scrollArea->scrollOffset.y() - scrollOffsetLines * lineHeight);
                                    cursorX = textPos.x() + lastWidth;
                                }
                                else
                                {
                                    // 光标不在可见区域，不显示
                                    cursorX = -1000.0F;
                                    cursorY = -1000.0F;
                                }
                            }

                            if (cursorX >= 0.0F && cursorY >= 0.0F && (SDL_GetTicks() / 500) % 2 == 0)
                            {
                                addRectFilledWithRounding({cursorX, cursorY},
                                                          {2.0F, lineHeight},
                                                          {1.0F, 1.0F, 1.0F, 1.0F},
                                                          {0, 0, 0, 0},
                                                          alpha);
                            }

                            if (sdlWindow && cursorX >= 0.0F && cursorY >= 0.0F)
                            {
                                SDL_Rect rect;
                                rect.x = static_cast<int>(cursorX);
                                rect.y = static_cast<int>(cursorY);
                                rect.w = 2;
                                rect.h = static_cast<int>(lineHeight);
                                SDL_SetTextInputArea(sdlWindow, &rect, 0);
                            }
                        }
                    }
                    else
                    {
                        // 没有 ScrollArea 的情况：显示末尾内容（保持原有行为）
                        const int maxLines = lineHeight > 0.0F ? static_cast<int>(textSize.y() / lineHeight) : 0;
                        const size_t startIndex = (maxLines > 0 && lines.size() > static_cast<size_t>(maxLines))
                                                      ? (lines.size() - static_cast<size_t>(maxLines))
                                                      : 0;

                        float y = textPos.y();
                        for (size_t i = startIndex; i < lines.size(); ++i)
                        {
                            const std::string& line = lines[i];
                            if (!line.empty())
                            {
                                addText(line,
                                        {textPos.x(), y},
                                        {textSize.x(), lineHeight},
                                        color,
                                        policies::Alignment::LEFT,
                                        alpha);
                            }
                            y += lineHeight;
                        }

                        // 绘制光标 (仅当获焦时) - 无 ScrollArea 分支
                        if (Registry::AnyOf<components::FocusedTag>(entity))
                        {
                            float cursorX = textPos.x();
                            float cursorY = textPos.y();
                            if (!lines.empty())
                            {
                                const std::string& lastLine = lines.back();
                                float lastWidth = measureTextWidth(lastLine);
                                const int visibleLineCount =
                                    maxLines > 0 ? std::min(maxLines, static_cast<int>(lines.size())) : 1;
                                cursorY = textPos.y() + (visibleLineCount - 1) * lineHeight;
                                cursorX = textPos.x() + lastWidth;
                            }

                            if ((SDL_GetTicks() / 500) % 2 == 0)
                            {
                                addRectFilledWithRounding({cursorX, cursorY},
                                                          {2.0F, lineHeight},
                                                          {1.0F, 1.0F, 1.0F, 1.0F},
                                                          {0, 0, 0, 0},
                                                          alpha);
                            }

                            if (sdlWindow)
                            {
                                SDL_Rect rect;
                                rect.x = static_cast<int>(cursorX);
                                rect.y = static_cast<int>(cursorY);
                                rect.w = 2;
                                rect.h = static_cast<int>(lineHeight);
                                SDL_SetTextInputArea(sdlWindow, &rect, 0);
                            }
                        }
                    }
                }

                if (pushScissor)
                {
                    m_scissorStack.pop_back();
                }
            }
        }

        // 图像渲染
        if (Registry::AnyOf<components::ImageTag>(entity))
        {
            const auto& imageComp = Registry::Get<components::Image>(entity);
            if (imageComp.textureId)
            {
                Eigen::Vector4f tint(imageComp.tintColor.red,
                                     imageComp.tintColor.green,
                                     imageComp.tintColor.blue,
                                     imageComp.tintColor.alpha);
                addImageBatch(static_cast<SDL_GPUTexture*>(imageComp.textureId),
                              pos,
                              size,
                              imageComp.uvMin,
                              imageComp.uvMax,
                              tint,
                              alpha);
            }
        }
    }

    /**
     * @brief 添加带圆角的填充矩形批次
     */
    void addRectFilledWithRounding(const Eigen::Vector2f& pos,
                                   const Eigen::Vector2f& size,
                                   const Eigen::Vector4f& color,
                                   const Eigen::Vector4f& radius,
                                   float opacity,
                                   float shadowSoft = 0.0F,
                                   float shadowOffsetX = 0.0F,
                                   float shadowOffsetY = 0.0F)
    {
        RenderBatch batch;
        if (!m_scissorStack.empty())
        {
            batch.scissorRect = m_scissorStack.back();
        }
        batch.texture = m_whiteTexture;

        // 设置 Push Constants（与着色器 PushConstants 结构体字段顺序一致）
        batch.pushConstants.screen_size[0] = m_screenWidth;
        batch.pushConstants.screen_size[1] = m_screenHeight;
        batch.pushConstants.rect_size[0] = size.x();
        batch.pushConstants.rect_size[1] = size.y();
        batch.pushConstants.radius[0] = radius.x(); // 左上
        batch.pushConstants.radius[1] = radius.y(); // 右上
        batch.pushConstants.radius[2] = radius.z(); // 右下
        batch.pushConstants.radius[3] = radius.w(); // 左下
        batch.pushConstants.shadow_soft = shadowSoft;
        batch.pushConstants.shadow_offset_x = shadowOffsetX;
        batch.pushConstants.shadow_offset_y = shadowOffsetY;
        batch.pushConstants.opacity = opacity;
        batch.pushConstants.padding = 0.0F;

        // 创建矩形顶点（四个角）
        Eigen::Vector2f max = pos + size;

        batch.vertices.push_back({{pos.x(), pos.y()}, {0.0F, 0.0F}, {color.x(), color.y(), color.z(), color.w()}});
        batch.vertices.push_back({{max.x(), pos.y()}, {1.0F, 0.0F}, {color.x(), color.y(), color.z(), color.w()}});
        batch.vertices.push_back({{max.x(), max.y()}, {1.0F, 1.0F}, {color.x(), color.y(), color.z(), color.w()}});
        batch.vertices.push_back({{pos.x(), max.y()}, {0.0F, 1.0F}, {color.x(), color.y(), color.z(), color.w()}});

        batch.indices = {0, 1, 2, 0, 2, 3};

        m_batches.push_back(std::move(batch));
    }

    /**
     * @brief 添加矩形边框（简化版，用线段绘制）
     */
    void addRect(const Eigen::Vector2f& min,
                 const Eigen::Vector2f& max,
                 const Eigen::Vector4f& color,
                 float thickness,
                 float opacity)
    {
        // 简化实现：用4个细矩形绘制边框
        addRectFilledWithRounding(min, {max.x() - min.x(), thickness}, color, {0, 0, 0, 0}, opacity);
        addRectFilledWithRounding(
            {min.x(), max.y() - thickness}, {max.x() - min.x(), thickness}, color, {0, 0, 0, 0}, opacity);
        addRectFilledWithRounding(min, {thickness, max.y() - min.y()}, color, {0, 0, 0, 0}, opacity);
        addRectFilledWithRounding(
            {max.x() - thickness, min.y()}, {thickness, max.y() - min.y()}, color, {0, 0, 0, 0}, opacity);
    }

    /**
     * @brief 添加文本渲染批次
     */
    void addText(const std::string& text,
                 const Eigen::Vector2f& pos,
                 const Eigen::Vector2f& size,
                 const Eigen::Vector4f& color,
                 policies::Alignment alignment,
                 float opacity)
    {
        if (!m_fontManager->isLoaded() || text.empty()) return;

        // 使用 stb_truetype 渲染文本到纹理
        uint32_t textWidth = 0;
        uint32_t textHeight = 0;

        SDL_GPUTexture* textTexture = m_textTextureCache->getOrUpload(text, color, textWidth, textHeight);

        if (textTexture == nullptr) return;

        float scale = m_fontManager->getOversampleScale();
        Eigen::Vector2f textSize(static_cast<float>(textWidth) / scale, static_cast<float>(textHeight) / scale);

        float drawX = pos.x();
        float drawY = pos.y();

        // 水平对齐
        if (utils::HasAlignment(alignment, policies::Alignment::HCENTER))
        {
            drawX += (size.x() - textSize.x()) * 0.5F;
        }
        else if (utils::HasAlignment(alignment, policies::Alignment::RIGHT))
        {
            drawX += size.x() - textSize.x();
        }

        // 垂直对齐
        if (utils::HasAlignment(alignment, policies::Alignment::VCENTER))
        {
            drawY += (size.y() - textSize.y()) * 0.5F;
        }
        else if (utils::HasAlignment(alignment, policies::Alignment::BOTTOM))
        {
            drawY += size.y() - textSize.y();
        }

        addImageBatch(textTexture, {drawX, drawY}, textSize, {0, 0}, {1, 1}, {1, 1, 1, 1}, opacity);
    }

    /**
     * @brief 添加图像渲染批次
     */
    void addImageBatch(SDL_GPUTexture* texture,
                       const Eigen::Vector2f& pos,
                       const Eigen::Vector2f& size,
                       const Eigen::Vector2f& uvMin,
                       const Eigen::Vector2f& uvMax,
                       const Eigen::Vector4f& tint,
                       float opacity)
    {
        RenderBatch batch;
        if (!m_scissorStack.empty())
        {
            batch.scissorRect = m_scissorStack.back();
        }
        batch.texture = texture;

        batch.pushConstants.screen_size[0] = m_screenWidth;
        batch.pushConstants.screen_size[1] = m_screenHeight;
        batch.pushConstants.rect_size[0] = size.x();
        batch.pushConstants.rect_size[1] = size.y();
        batch.pushConstants.radius[0] = 0.0F; // 左上
        batch.pushConstants.radius[1] = 0.0F; // 右上
        batch.pushConstants.radius[2] = 0.0F; // 右下
        batch.pushConstants.radius[3] = 0.0F; // 左下
        batch.pushConstants.shadow_soft = 0.0F;
        batch.pushConstants.shadow_offset_x = 0.0F;
        batch.pushConstants.shadow_offset_y = 0.0F;
        batch.pushConstants.opacity = opacity;
        batch.pushConstants.padding = 0.0F;

        Eigen::Vector2f max = pos + size;

        batch.vertices.push_back(
            {{pos.x(), pos.y()}, {uvMin.x(), uvMin.y()}, {tint.x(), tint.y(), tint.z(), tint.w()}});
        batch.vertices.push_back(
            {{max.x(), pos.y()}, {uvMax.x(), uvMin.y()}, {tint.x(), tint.y(), tint.z(), tint.w()}});
        batch.vertices.push_back(
            {{max.x(), max.y()}, {uvMax.x(), uvMax.y()}, {tint.x(), tint.y(), tint.z(), tint.w()}});
        batch.vertices.push_back(
            {{pos.x(), max.y()}, {uvMin.x(), uvMax.y()}, {tint.x(), tint.y(), tint.z(), tint.w()}});

        batch.indices = {0, 1, 2, 0, 2, 3};

        m_batches.push_back(std::move(batch));
    }

    /**
     * @brief 渲染图标
     * @param entity 实体
     * @param iconComp Icon组件指针
     * @param widgetPos 控件位置
     * @param widgetSize 控件尺寸
     * @param alpha 透明度
     */
    void renderIcon(entt::entity entity,
                    const components::Icon* iconComp,
                    const Eigen::Vector2f& widgetPos,
                    const Eigen::Vector2f& widgetSize,
                    float alpha)
    {
        if (!iconComp) return;

        // 根据类型判断是否有有效数据
        if (iconComp->type == policies::IconType::Texture && !iconComp->textureId) return;
        if (iconComp->type == policies::IconType::Font && (!iconComp->fontHandle || iconComp->codepoint == 0)) return;

        // 获取文本组件以计算文本尺寸
        const auto* textComp = Registry::TryGet<components::Text>(entity);

        // 计算文本实际尺寸
        Eigen::Vector2f textSize{0.0F, 0.0F};
        if (textComp && !textComp->content.empty())
        {
            float textWidth = measureTextWidth(textComp->content);
            float textHeight = m_fontManager->isLoaded() ? static_cast<float>(m_fontManager->getFontHeight()) : 16.0F;
            textSize = {textWidth, textHeight};
        }

        // 图标位置计算
        Eigen::Vector2f iconPos;
        Eigen::Vector2f iconSize{iconComp->size.x(), iconComp->size.y()};

        switch (iconComp->position)
        {
            case policies::IconPosition::Left:
                // 图标在文本左侧
                iconPos.x() = widgetPos.x() + (widgetSize.x() - textSize.x() - iconSize.x() - iconComp->spacing) * 0.5F;
                iconPos.y() = widgetPos.y() + (widgetSize.y() - iconSize.y()) * 0.5F;
                break;

            case policies::IconPosition::Right:
                // 图标在文本右侧
                iconPos.x() = widgetPos.x() + (widgetSize.x() + textSize.x() + iconComp->spacing - iconSize.x()) * 0.5F;
                iconPos.y() = widgetPos.y() + (widgetSize.y() - iconSize.y()) * 0.5F;
                break;

            case policies::IconPosition::Top:
                // 图标在文本上方
                iconPos.x() = widgetPos.x() + (widgetSize.x() - iconSize.x()) * 0.5F;
                iconPos.y() = widgetPos.y() + (widgetSize.y() - textSize.y() - iconSize.y() - iconComp->spacing) * 0.5F;
                break;

            case policies::IconPosition::Bottom:
                // 图标在文本下方
                iconPos.x() = widgetPos.x() + (widgetSize.x() - iconSize.x()) * 0.5F;
                iconPos.y() = widgetPos.y() + (widgetSize.y() + textSize.y() + iconComp->spacing - iconSize.y()) * 0.5F;
                break;
        }

        // 根据类型渲染图标
        if (iconComp->type == policies::IconType::Texture)
        {
            // 渲染纹理图标
            Eigen::Vector4f tint(iconComp->tintColor.red,
                                 iconComp->tintColor.green,
                                 iconComp->tintColor.blue,
                                 iconComp->tintColor.alpha);

            addImageBatch(static_cast<SDL_GPUTexture*>(iconComp->textureId),
                          iconPos,
                          iconSize,
                          {iconComp->uvMin.x(), iconComp->uvMin.y()},
                          {iconComp->uvMax.x(), iconComp->uvMax.y()},
                          tint,
                          alpha);
        }
        else if (iconComp->type == policies::IconType::Font)
        {
            // 渲染字体图标
            renderFontIcon(iconComp, iconPos, iconSize, alpha);
        }
    }

    /**
     * @brief 渲染字体图标（IconFont）
     */
    void renderFontIcon(const components::Icon* iconComp,
                        const Eigen::Vector2f& pos,
                        const Eigen::Vector2f& size,
                        float alpha)
    {
        if (!iconComp || !iconComp->fontHandle || iconComp->codepoint == 0) return;

        // 将 codepoint 转换为 UTF-8 字符串
        std::string iconChar;
        uint32_t cp = iconComp->codepoint;
        if (cp < 0x80)
        {
            iconChar.push_back(static_cast<char>(cp));
        }
        else if (cp < 0x800)
        {
            iconChar.push_back(static_cast<char>(0xC0 | (cp >> 6)));
            iconChar.push_back(static_cast<char>(0x80 | (cp & 0x3F)));
        }
        else if (cp < 0x10000)
        {
            iconChar.push_back(static_cast<char>(0xE0 | (cp >> 12)));
            iconChar.push_back(static_cast<char>(0x80 | ((cp >> 6) & 0x3F)));
            iconChar.push_back(static_cast<char>(0x80 | (cp & 0x3F)));
        }
        else
        {
            iconChar.push_back(static_cast<char>(0xF0 | (cp >> 18)));
            iconChar.push_back(static_cast<char>(0x80 | ((cp >> 12) & 0x3F)));
            iconChar.push_back(static_cast<char>(0x80 | ((cp >> 6) & 0x3F)));
            iconChar.push_back(static_cast<char>(0x80 | (cp & 0x3F)));
        }

        // 使用 IconFont 渲染文本
        // TODO: IconFont 支持需要重新实现，因为已经移除了 SDL_ttf
        // 暂时跳过 IconFont 渲染
        // FontManager* iconFont = static_cast<FontManager*>(iconComp->fontHandle);

        // 渲染图标字符（使用默认字体）
        Eigen::Vector4f color(
            iconComp->tintColor.red, iconComp->tintColor.green, iconComp->tintColor.blue, iconComp->tintColor.alpha);

        addText(iconChar, pos, size, color, policies::Alignment::CENTER, alpha);
    }

    static size_t nextUtf8CharLen(unsigned char c)
    {
        if (c < 0x80) return 1;
        if ((c & 0xE0) == 0xC0) return 2;
        if ((c & 0xF0) == 0xE0) return 3;
        if ((c & 0xF8) == 0xF0) return 4;
        return 1;
    }

    float measureTextWidth(const std::string& text) const
    {
        if (!m_fontManager->isLoaded() || text.empty()) return 0.0F;
        return static_cast<float>(m_fontManager->measureTextWidth(text));
    }

    std::string ltrimSpaces(std::string text) const
    {
        size_t i = 0;
        while (i < text.size() && (text[i] == ' ' || text[i] == '\t'))
        {
            ++i;
        }
        if (i > 0) text.erase(0, i);
        return text;
    }

    std::vector<std::string> wrapTextLines(const std::string& text, int maxWidth, policies::TextWrap wrapMode) const
    {
        std::vector<std::string> lines;
        if (!m_fontManager->isLoaded())
        {
            lines.push_back(text);
            return lines;
        }

        if (wrapMode == policies::TextWrap::None || maxWidth <= 0)
        {
            lines.push_back(text);
            return lines;
        }

        size_t start = 0;
        while (start <= text.size())
        {
            size_t end = text.find('\n', start);
            if (end == std::string::npos) end = text.size();
            std::string segment = text.substr(start, end - start);

            if (segment.empty())
            {
                lines.emplace_back();
            }
            else
            {
                while (!segment.empty())
                {
                    int measuredWidth = 0;
                    size_t measuredLength = 0;
                    measuredWidth =
                        m_fontManager->measureString(segment.c_str(), segment.size(), maxWidth, &measuredLength);

                    if (measuredLength == 0)
                    {
                        size_t len = nextUtf8CharLen(static_cast<unsigned char>(segment[0]));
                        lines.push_back(segment.substr(0, len));
                        segment.erase(0, len);
                        segment = ltrimSpaces(segment);
                        continue;
                    }

                    if (measuredLength >= segment.size())
                    {
                        lines.push_back(segment);
                        segment.clear();
                        break;
                    }

                    size_t breakLen = measuredLength;
                    if (wrapMode == policies::TextWrap::Word)
                    {
                        size_t spacePos = segment.find_last_of(' ', measuredLength - 1);
                        if (spacePos != std::string::npos && spacePos > 0)
                        {
                            breakLen = spacePos;
                        }
                    }

                    lines.push_back(segment.substr(0, breakLen));
                    segment.erase(0, breakLen);
                    segment = ltrimSpaces(segment);
                }
            }

            if (end == text.size()) break;
            start = end + 1;
        }

        return lines;
    }

    std::string getTailThatFits(const std::string& text, int maxWidth, float& outWidth) const
    {
        outWidth = 0.0F;
        if (!m_fontManager->isLoaded() || text.empty() || maxWidth <= 0) return std::string();

        size_t start = 0;
        while (start < text.size())
        {
            int measuredWidth = 0;
            size_t measuredLength = 0;
            measuredWidth =
                m_fontManager->measureString(text.c_str() + start, text.size() - start, maxWidth, &measuredLength);

            if (measuredLength == text.size() - start)
            {
                outWidth = static_cast<float>(measuredWidth);
                return text.substr(start);
            }

            start += nextUtf8CharLen(static_cast<unsigned char>(text[start]));
        }

        return std::string();
    }

    float getAncestorScrollAreaTextWidth(entt::entity entity) const
    {
        entt::entity current = entity;
        while (current != entt::null && Registry::Valid(current))
        {
            const auto* hierarchy = Registry::TryGet<components::Hierarchy>(current);
            if (hierarchy == nullptr) break;
            current = hierarchy->parent;
            if (current == entt::null) break;

            if (Registry::AnyOf<components::ScrollArea>(current))
            {
                const auto* size = Registry::TryGet<components::Size>(current);
                if (size == nullptr) return 0.0F;

                float width = size->size.x();
                if (const auto* padding = Registry::TryGet<components::Padding>(current))
                {
                    width -= (padding->values.y() + padding->values.z());
                }
                return std::max(0.0F, width);
            }
        }
        return 0.0F;
    }

    void addWrappedText(const std::string& text,
                        const Eigen::Vector2f& pos,
                        const Eigen::Vector2f& size,
                        const Eigen::Vector4f& color,
                        policies::Alignment alignment,
                        policies::TextWrap wrapMode,
                        float wrapWidth,
                        float opacity)
    {
        if (!m_fontManager->isLoaded() || text.empty() || wrapWidth <= 0.0F) return;

        const float lineHeight = static_cast<float>(m_fontManager->getFontHeight());
        if (lineHeight <= 0.0F) return;

        std::vector<std::string> lines = wrapTextLines(text, static_cast<int>(wrapWidth), wrapMode);
        const float totalHeight = static_cast<float>(lines.size()) * lineHeight;

        float startY = pos.y();
        if (ui::utils::HasAlignment(alignment, policies::Alignment::VCENTER))
        {
            startY += (size.y() - totalHeight) * 0.5F;
        }
        else if (ui::utils::HasAlignment(alignment, policies::Alignment::BOTTOM))
        {
            startY += size.y() - totalHeight;
        }

        const uint8_t horizontalMask = static_cast<uint8_t>(policies::Alignment::LEFT) |
                                       static_cast<uint8_t>(policies::Alignment::HCENTER) |
                                       static_cast<uint8_t>(policies::Alignment::RIGHT);
        const uint8_t alignValue = static_cast<uint8_t>(alignment);
        policies::Alignment horizontalAlign = static_cast<policies::Alignment>(alignValue & horizontalMask);
        if (horizontalAlign == policies::Alignment::NONE)
        {
            horizontalAlign = policies::Alignment::LEFT;
        }

        float y = startY;
        for (const auto& line : lines)
        {
            if (!line.empty())
            {
                addText(line, {pos.x(), y}, {wrapWidth, lineHeight}, color, horizontalAlign, opacity);
            }
            y += lineHeight;
        }
    }

    /**
     * @brief 执行 GPU 渲染（批次渲染）
     */
    void renderToGPU(SDL_Window* window, int width, int height)
    {
        static bool firstRender = true;

        SDL_GPUDevice* device = m_deviceManager->getDevice();
        if (device == nullptr) return;

        // 获取命令缓冲区
        SDL_GPUCommandBuffer* cmdBuf = SDL_AcquireGPUCommandBuffer(device);
        if (cmdBuf == nullptr) return;

        // 获取交换链纹理
        SDL_GPUTexture* swapchainTexture = nullptr;
        if (!SDL_WaitAndAcquireGPUSwapchainTexture(cmdBuf, window, &swapchainTexture, nullptr, nullptr))
        {
            if (firstRender) Logger::warn("Swapchain texture not ready yet.");
            SDL_CancelGPUCommandBuffer(cmdBuf);
            return;
        }

        if (firstRender)
        {
            firstRender = false;
        }

        if (swapchainTexture == nullptr)
        {
            SDL_SubmitGPUCommandBuffer(cmdBuf);
            return;
        }

        // 开始渲染通道
        SDL_GPUColorTargetInfo colorTarget = {};
        colorTarget.texture = swapchainTexture;
        colorTarget.clear_color = {0.0F, 0.0F, 0.0F, 1.0F};
        colorTarget.load_op = SDL_GPU_LOADOP_CLEAR;
        colorTarget.store_op = SDL_GPU_STOREOP_STORE;

        SDL_GPURenderPass* renderPass = SDL_BeginGPURenderPass(cmdBuf, &colorTarget, 1, nullptr);

        // 绑定管线
        SDL_BindGPUGraphicsPipeline(renderPass, m_pipelineCache->getPipeline());

        // 设置视口
        SDL_GPUViewport viewport = {};
        viewport.x = 0;
        viewport.y = 0;
        viewport.w = static_cast<float>(width);
        viewport.h = static_cast<float>(height);
        viewport.min_depth = 0.0F;
        viewport.max_depth = 1.0F;
        SDL_SetGPUViewport(renderPass, &viewport);

        uint32_t currentBatchCount = 0;

        // 逐批次渲染
        for (const auto& batch : m_batches)
        {
            if (batch.vertices.empty() || batch.indices.empty()) continue;

            currentBatchCount++;
            m_stats.vertexCount += static_cast<uint32_t>(batch.vertices.size());

            // 设置裁剪
            if (batch.scissorRect.has_value())
            {
                SDL_Rect r = batch.scissorRect.value();
                SDL_SetGPUScissor(renderPass, &r);
            }
            else
            {
                // Default scissor (entire expected viewport?)
            }

            // 上传顶点和索引数据
            SDL_GPUBuffer* vertexBuffer = uploadBatchVertices(batch.vertices);
            SDL_GPUBuffer* indexBuffer = uploadBatchIndices(batch.indices);

            if (vertexBuffer == nullptr || indexBuffer == nullptr)
            {
                continue;
            }

            // 绑定顶点缓冲区
            SDL_GPUBufferBinding vertexBinding = {};
            vertexBinding.buffer = vertexBuffer;
            vertexBinding.offset = 0;
            SDL_BindGPUVertexBuffers(renderPass, 0, &vertexBinding, 1);

            // 绑定索引缓冲区
            SDL_GPUBufferBinding indexBinding = {};
            indexBinding.buffer = indexBuffer;
            indexBinding.offset = 0;
            SDL_BindGPUIndexBuffer(renderPass, &indexBinding, SDL_GPU_INDEXELEMENTSIZE_16BIT);

            // 绑定纹理和采样器
            if (batch.texture != nullptr)
            {
                SDL_GPUTextureSamplerBinding texSamplerBinding = {};
                texSamplerBinding.texture = batch.texture;
                texSamplerBinding.sampler = m_pipelineCache->getSampler();
                SDL_BindGPUFragmentSamplers(renderPass, 0, &texSamplerBinding, 1);
            }

            // 推送 Push Constants
            SDL_PushGPUVertexUniformData(cmdBuf, 0, &batch.pushConstants, sizeof(UiPushConstants));
            SDL_PushGPUFragmentUniformData(cmdBuf, 0, &batch.pushConstants, sizeof(UiPushConstants));

            // 绘制
            SDL_DrawGPUIndexedPrimitives(renderPass, static_cast<uint32_t>(batch.indices.size()), 1, 0, 0, 0);

            // 释放临时缓冲区（实际应该池化复用）
            SDL_ReleaseGPUBuffer(device, vertexBuffer);
            SDL_ReleaseGPUBuffer(device, indexBuffer);
        }

        m_stats.batchCount += currentBatchCount;

        // 结束渲染通道
        SDL_EndGPURenderPass(renderPass);

        // 提交命令缓冲区
        SDL_SubmitGPUCommandBuffer(cmdBuf);
    }

    /**
     * @brief 上传批次顶点数据到 GPU 缓冲区
     */
    SDL_GPUBuffer* uploadBatchVertices(const std::vector<Vertex>& vertices)
    {
        SDL_GPUDevice* device = m_deviceManager->getDevice();
        if (device == nullptr) return nullptr;

        const uint32_t bufferSize = static_cast<uint32_t>(vertices.size() * sizeof(Vertex));

        SDL_GPUBufferCreateInfo bufferInfo = {};
        bufferInfo.usage = SDL_GPU_BUFFERUSAGE_VERTEX;
        bufferInfo.size = bufferSize;
        SDL_GPUBuffer* buffer = SDL_CreateGPUBuffer(device, &bufferInfo);

        if (buffer == nullptr) return nullptr;

        // 上传数据
        SDL_GPUTransferBufferCreateInfo transferInfo = {};
        transferInfo.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
        transferInfo.size = bufferSize;

        SDL_GPUTransferBuffer* transferBuffer = SDL_CreateGPUTransferBuffer(device, &transferInfo);

        if (transferBuffer == nullptr)
        {
            SDL_ReleaseGPUBuffer(device, buffer);
            return nullptr;
        }

        void* data = SDL_MapGPUTransferBuffer(device, transferBuffer, false);
        SDL_memcpy(data, vertices.data(), bufferSize);
        SDL_UnmapGPUTransferBuffer(device, transferBuffer);

        SDL_GPUCommandBuffer* uploadCmd = SDL_AcquireGPUCommandBuffer(device);
        SDL_GPUCopyPass* copyPass = SDL_BeginGPUCopyPass(uploadCmd);

        SDL_GPUTransferBufferLocation srcLocation = {};
        srcLocation.transfer_buffer = transferBuffer;
        srcLocation.offset = 0;

        SDL_GPUBufferRegion dstRegion = {};
        dstRegion.buffer = buffer;
        dstRegion.offset = 0;
        dstRegion.size = bufferSize;

        SDL_UploadToGPUBuffer(copyPass, &srcLocation, &dstRegion, false);
        SDL_EndGPUCopyPass(copyPass);
        SDL_SubmitGPUCommandBuffer(uploadCmd);

        SDL_ReleaseGPUTransferBuffer(device, transferBuffer);

        return buffer;
    }

    /**
     * @brief 上传批次索引数据到 GPU 缓冲区
     */
    SDL_GPUBuffer* uploadBatchIndices(const std::vector<uint16_t>& indices)
    {
        SDL_GPUDevice* device = m_deviceManager->getDevice();
        if (device == nullptr) return nullptr;

        const uint32_t bufferSize = static_cast<uint32_t>(indices.size() * sizeof(uint16_t));

        SDL_GPUBufferCreateInfo bufferInfo = {};
        bufferInfo.usage = SDL_GPU_BUFFERUSAGE_INDEX;
        bufferInfo.size = bufferSize;
        SDL_GPUBuffer* buffer = SDL_CreateGPUBuffer(device, &bufferInfo);

        if (buffer == nullptr) return nullptr;

        SDL_GPUTransferBufferCreateInfo transferInfo = {};
        transferInfo.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
        transferInfo.size = bufferSize;

        SDL_GPUTransferBuffer* transferBuffer = SDL_CreateGPUTransferBuffer(device, &transferInfo);

        if (transferBuffer == nullptr)
        {
            SDL_ReleaseGPUBuffer(device, buffer);
            return nullptr;
        }

        void* data = SDL_MapGPUTransferBuffer(device, transferBuffer, false);
        SDL_memcpy(data, indices.data(), bufferSize);
        SDL_UnmapGPUTransferBuffer(device, transferBuffer);

        SDL_GPUCommandBuffer* uploadCmd = SDL_AcquireGPUCommandBuffer(device);
        SDL_GPUCopyPass* copyPass = SDL_BeginGPUCopyPass(uploadCmd);

        SDL_GPUTransferBufferLocation srcLocation = {};
        srcLocation.transfer_buffer = transferBuffer;
        srcLocation.offset = 0;

        SDL_GPUBufferRegion dstRegion = {};
        dstRegion.buffer = buffer;
        dstRegion.offset = 0;
        dstRegion.size = bufferSize;

        SDL_UploadToGPUBuffer(copyPass, &srcLocation, &dstRegion, false);
        SDL_EndGPUCopyPass(copyPass);
        SDL_SubmitGPUCommandBuffer(uploadCmd);

        SDL_ReleaseGPUTransferBuffer(device, transferBuffer);

        return buffer;
    }

private:
    std::unique_ptr<managers::DeviceManager> m_deviceManager;
    std::unique_ptr<managers::FontManager> m_fontManager;
    std::unique_ptr<managers::PipelineCache> m_pipelineCache;
    std::unique_ptr<managers::TextTextureCache> m_textTextureCache;
    std::unique_ptr<managers::BatchManager> m_batchManager;
    std::unique_ptr<managers::CommandBuffer> m_commandBuffer;

    // 渲染器列表
    std::vector<std::unique_ptr<core::IRenderer>> m_renderers;

    RenderStats m_stats;
    SDL_GPUTexture* m_whiteTexture = nullptr; // 默认白色纹理用于纯色渲染

    // 当前屏幕尺寸
    float m_screenWidth = 0.0F;
    float m_screenHeight = 0.0F;
};

} // namespace ui::systems
